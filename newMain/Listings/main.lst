C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2020 23:49:26 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include "std_macros.h"
   3          #include "DIO.h"
   4          #include "Keypad.h"
   5          #include "SevenSegments.h"
   6          #include "stepper.h"
   7          #define NOTPRESSED 0xff
   8          #define true 1
   9          #define false 0
  10          
  11          void checkPresed(void);
  12          
  13          
  14          void elevUP(void);
  15          void elecvDOWN(void);
  16          void elevSTOP(void);
  17          unsigned char presed,step,buttonFlagPresed;
  18          char sevensegmentValue,elevator;
  19          char opencounter=0;
  20          char upvalue = 0;
  21          char downvalue = 0;
  22          char wait;
  23          char open = false;
  24          char close = false;
  25          char up = false;
  26          char down = false;
  27          char buttonPresed[8] = {1,1,1,1,1,1,1,1};
  28          char buttonPresedFlags[8] = {0,0,0,0,0,0,0,0};
  29          char keypadFlags[5] = {0,1,2,3,4};
  30          char keypadvalues[5] = {0};
  31          char arr[4] = {0,1,2,3}; // sevenSegments number
  32          
  33          sbit led = P0^0;
  34          volatile char count = 0;
  35          volatile char count2 = 0;
  36          /*
  37          void ext_int_0() interrupt 0
  38          { 
  39              count = 0;
  40          }
  41          */
  42          
  43          
  44          void timer1_isr() interrupt 3
  45          {
  46   1        TH1 = 0X4B;        //Load the timer value
  47   1          TL1 = 0XFD;
  48   1        wait++;
  49   1        up = false;
  50   1              down= false;
  51   1      }
  52          void timer0_isr() interrupt 1
  53          {
  54   1        TH0 = 0X4B;        //ReLoad the timer value
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2020 23:49:26 PAGE 2   

  55   1          TL0 = 0XFD;
  56   1          count++;        // Toggle the LED pin 
  57   1          count2++;
  58   1      }
  59          
  60          void main (void)
  61          {
  62   1        
  63   1        
  64   1          WDTCN = 0xDE;
  65   1          WDTCN = 0xAD;
  66   1          keypad_vInit(1);
  67   1      
  68   1          seven_seg_init(0,0);
  69   1          seven_seg_init(0,1);
  70   1          sevensegmentValue = 0;
  71   1          seven_seg_write(0,sevensegmentValue,0);
  72   1          
  73   1          P3MDOUT &= 0x00;
  74   1          P3 = 0xff;
  75   1        
  76   1          TMOD = 0x01;       //Timer0 mode 1 
  77   1          SET_BIT(TMOD,4);
  78   1          TH1 = 0X4B;        //Load the timer value
  79   1          TL1 = 0XFD;
  80   1          TH0 = 0X4B;        //Load the timer value
  81   1          TL0 = 0XFD;
  82   1          TR0 = 1;           //turn ON Timer zero
  83   1          TR1 = 1;
  84   1          ET0 = 1;           //Enable TImer0 Interrupt
  85   1          
  86   1          EA = 1; 
  87   1         
  88   1         //DIO_setPin_OutPutMode(2,0,1);
  89   1         //DIO_setPin_OutPutMode(2,1,1);
  90   1        
  91   1      
  92   1        while(1)
  93   1        {
  94   2      
  95   2          checkPresed();
  96   2          for(step=0;step<8;step++)
  97   2            {
  98   3              if (buttonPresedFlags[step] == 1) 
  99   3              {
 100   4                buttonFlagPresed = 1;
 101   4              }
 102   3            }
 103   2          while(buttonFlagPresed)
 104   2        {
 105   3          
 106   3            if(buttonPresedFlags[0]==1 )  
 107   3              {
 108   4                if (sevensegmentValue == 0)
 109   4                  {
 110   5                    if(down)
 111   5                      {
 112   6                        down = false ;
 113   6                      }
 114   5                        open=true;
 115   5                        buttonPresedFlags[0] = 0;
 116   5                  }
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2020 23:49:26 PAGE 3   

 117   4                else
 118   4                  {
 119   5                    elevator = 0;
 120   5                  }
 121   4              }
 122   3            if(buttonPresedFlags[3]==1 || buttonPresedFlags[4]==1)  
 123   3              {
 124   4                if (sevensegmentValue == 1)
 125   4                  {
 126   5                    if( down && buttonPresedFlags[4])
 127   5                      {
 128   6                        open=true;
 129   6                        buttonPresedFlags[4] = 0;
 130   6                        down = false;
 131   6                        
 132   6                      }
 133   5                    else if (up && buttonPresedFlags[3])
 134   5                      { 
 135   6                        open=true;
 136   6                        buttonPresedFlags[3] = 0;
 137   6                        up = false;
 138   6                      }
 139   5                    else if ( !up && !down )
 140   5                      {
 141   6                        open=true;
 142   6                      }
 143   5                  }
 144   4                else
 145   4                  {
 146   5                    elevator = 1;
 147   5                  }
 148   4              }
 149   3              if(buttonPresedFlags[5]==1 || buttonPresedFlags[6]==1)  
 150   3              {
 151   4                if (sevensegmentValue == 2)
 152   4                  {
 153   5                    if( down && buttonPresedFlags[6])
 154   5                      {           
 155   6                        buttonPresedFlags[6] = 0;
 156   6                        down = false;
 157   6                        open = true;  
 158   6                        
 159   6                      }
 160   5                    else if (up && buttonPresedFlags[5])
 161   5                      { 
 162   6                        buttonPresedFlags[5] = 0;
 163   6                        open = true;
 164   6                        up = false;
 165   6                      }
 166   5                    else
 167   5                    {
 168   6                      open = true;
 169   6                    }
 170   5                  }
 171   4                else
 172   4                  {
 173   5                    elevator = 2;
 174   5                  }
 175   4              }
 176   3              if(buttonPresedFlags[1]==1) 
 177   3              {
 178   4                if (sevensegmentValue == 3)
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2020 23:49:26 PAGE 4   

 179   4                  {
 180   5                    if (up)
 181   5                      { 
 182   6                        up = false;
 183   6                      }
 184   5                      open=true;
 185   5                      buttonPresedFlags[1] = 0;
 186   5                  }
 187   4                else
 188   4                  {
 189   5                    elevator = 3;
 190   5                  }
 191   4              }
 192   3              checkPresed();
 193   3            if(sevensegmentValue < elevator)
 194   3              {
 195   4                up = true;
 196   4              }
 197   3            else if(sevensegmentValue > elevator)
 198   3              {
 199   4                down = true;
 200   4              }
 201   3            else
 202   3            {
 203   4              up = false;
 204   4              down = false;
 205   4            }
 206   3          
 207   3            
 208   3              if(open)
 209   3            {   
 210   4              motor_rotate(2,1,0);
 211   4              open=false;
 212   4              up = false;
 213   4              down= false;
 214   4              ET1= 1;
 215   4            }
 216   3            if(close)
 217   3            {
 218   4              motor_rotate(2,1,1);
 219   4              close = false;
 220   4              up = false;
 221   4              down= false;
 222   4            }
 223   3            if(wait >= 40)
 224   3            {
 225   4              close = true;
 226   4              ET1= 0;
 227   4              wait = 0;
 228   4              up = false;
 229   4              down= false;
 230   4            }   
 231   3          if(count >= 20 && up)
 232   3            {
 233   4              if(upvalue >= 3)
 234   4                {
 235   5                  sevensegmentValue++;
 236   5                  seven_seg_write(0,sevensegmentValue,0);
 237   5                  upvalue = 0;
 238   5                }
 239   4                upvalue++;
 240   4                motor_rotate(2,0,0);
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2020 23:49:26 PAGE 5   

 241   4                  count =0;   
 242   4            }
 243   3            
 244   3          if(count >= 20 && down)
 245   3            {
 246   4              if(downvalue >= 3)
 247   4                {
 248   5                  sevensegmentValue--;
 249   5                  seven_seg_write(0,sevensegmentValue,0);
 250   5                  downvalue = 0;
 251   5                }
 252   4                downvalue++;
 253   4                motor_rotate(2,0,1);
 254   4                count =0;
 255   4            }
 256   3      
 257   3        }
 258   2          
 259   2      }
 260   1        } 
 261          /*
 262          void elevUP(void)
 263          {
 264            if(count2 >= 30)
 265            {
 266              motor_rotate(2,0,0);
 267              count2 =0;
 268            }
 269          }
 270          void elecvDOWN(void)
 271          {
 272            if(count2 >= 30)
 273            {
 274              motor_rotate(2,0,1);
 275              count2 =0;
 276            }
 277          }
 278          */
 279          /*
 280          void open(void)
 281          {
 282            if(count2 >= 30)
 283            {
 284              motor_rotate(2,1,1);
 285              count2 =0;
 286            }
 287          } 
 288          void close(void)
 289          {
 290            count3 = 0;
 291            if (count3 <=50)
 292            {
 293              if(count2 >= 30)
 294              {
 295                motor_rotate(2,1,0);
 296                count2 =0;
 297              }
 298            }
 299          }
 300          */
 301          
 302            
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2020 23:49:26 PAGE 6   

 303          /*
 304          void elevUP(void)
 305          {
 306            SET_BIT(P2,0);
 307            CLR_BIT(P2,1);
 308          }
 309          void elecvDOWN(void)
 310          {
 311            CLR_BIT(P2,0);
 312            SET_BIT(P2,1);
 313          }
 314          void elevSTOP(void)
 315          {
 316            DIO_write(2,0,1);
 317            DIO_write(2,1,1);
 318          }
 319          void open(void)
 320          {
 321            SET_BIT(P2,4);
 322            CLR_BIT(P2,5);
 323          } 
 324          void close(void)
 325          {
 326            CLR_BIT(P2,4);
 327            SET_BIT(P2,5);
 328          } 
 329          void stop(void)
 330          {
 331          CLR_BIT(P2,5);
 332            CLR_BIT(P2,4);
 333          }
 334          */
 335          
 336          void checkPresed(void)
 337            {
 338   1          for(step=0;step<8;step++)
 339   1          {
 340   2            buttonPresed[step]=DIO_read(3,step);
 341   2            delay_ms(1);
 342   2          }
 343   1          for(step=0;step<8;step++)
 344   1          {
 345   2            if(0 == buttonPresed[step])
 346   2            {
 347   3              buttonPresedFlags[step] = 1;
 348   3            }
 349   2          }
 350   1        }
 351              


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    728    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
